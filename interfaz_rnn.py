# -*- coding: utf-8 -*-
"""Interfaz_RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ANP3HDlKWE1emtyfYjUfF07-gEhoJ5-1
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import base64  # ‚Üê NECESARIO para mostrar im√°genes con base64
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay, roc_curve, roc_auc_score
from sklearn.preprocessing import LabelBinarizer
import matplotlib.pyplot as plt
from PIL import Image

# T√≠tulo e imagen principal
st.title("Diagn√≥stico del Estado Nutricional de Gestantes en el departamento de Huancavelica")
st.markdown("Aplicaci√≥n desarrollada aplicando Redes Neuronales para diagnosticar el estado nutricional de gestantes.")

# Imagen ilustrativa (opcional)
try:
    with open("img1.jpg", "rb") as image_file:
        img_bytes = image_file.read()
        img_base64 = base64.b64encode(img_bytes).decode()
        st.markdown(
            f"""
            <div style="text-align:center;">
                <img src="data:image/jpg;base64,{img_base64}" width="200">
                <p><b>Evaluaci√≥n del estado nutricional de gestantes</b></p>
            </div>
            """,
            unsafe_allow_html=True
        )
except:
    st.warning("No se encontr√≥ la imagen 'img1.jpg'")

# Cargar modelo entrenado (.pkl)
model = joblib.load("mlp_classifier_model.pkl")

# Obtener las columnas esperadas por el modelo
try:
    expected_columns = model.feature_names_in_
except:
    st.error("El modelo no contiene informaci√≥n sobre las columnas usadas en el entrenamiento.")
    st.stop()


# Sidebar informativo
st.sidebar.header("Opciones de visualizaci√≥n")
show_sample = st.sidebar.checkbox("üìã Mostrar muestra del dataset")
show_metrics = st.sidebar.checkbox("üìä Mostrar m√©tricas del modelo")
show_conf_matrix = st.sidebar.checkbox("üìâ Mostrar matriz de confusi√≥n")
show_roc = st.sidebar.checkbox("üìà Mostrar curva ROC")

# === CARGAR Y PREPROCESAR DATOS ORIGINALES ===
df = pd.read_csv("Gestantes Huancavelica.csv")
df = df[df["Departamento"] == "HUANCAVELICA"].copy()
df.replace(['', ' ', '--', 'NA', 'N/A'], np.nan, inplace=True)

cols = ['Provincia', 'Edad', 'Ppg', 'Peso', 'Talla', 'Edad_Gest', 'AlturaREN', 'Dx_CLAP']
df = df[cols]

# Imputaci√≥n
for col in ['Edad', 'Ppg', 'Peso', 'Talla', 'Edad_Gest']:
    df[col] = pd.to_numeric(df[col], errors='coerce')
    df[col].fillna(df[col].mean(), inplace=True)

df = df[df['Provincia'].notna()]
df = df[df['Dx_CLAP'].notna()]

# Preparar X, y
X = df.drop(columns='Dx_CLAP')
y = df['Dx_CLAP']
X_encoded = pd.get_dummies(X, columns=['Provincia'], drop_first=False)

# Train/test split fiel
X_train, X_test, y_train, y_test = train_test_split(X_encoded, y, test_size=0.3, random_state=42)











# Opciones para provincia (codificadas como en el entrenamiento)
provincia_options = ['HUANCAVELICA', 'ACOBAMBA', 'ACORIA', 'CASTROVIRREYNA',
                     'CHURCAMPA', 'ANGARAES', 'HUAYTARA', 'TAYACAJA']


# Formulario de entrada
st.header("Ingrese los datos de la gestante")

Provincia = st.selectbox("Provincia", provincia_options)
Edad = st.number_input("Edad (a√±os)", min_value=10, max_value=50, value=25)
Ppg = st.number_input("Peso pregestacional (kg)", min_value=30.0, max_value=150.0, value=60.0)
Peso = st.number_input("Peso actual (kg)", min_value=30.0, max_value=150.0, value=65.0)
Talla = st.number_input("Talla (cm)", min_value=130.0, max_value=200.0, value=160.0)
Edad_Gest = st.slider("Edad gestacional (semanas)", 4, 42, 20)
AlturaREN = st.number_input("Altura sobre el nivel del mar (msnm)", min_value=0.0, max_value=5000.0, value=3000.0)

# Crear DataFrame base
input_dict = {
    'Edad': Edad,
    'Ppg': Ppg,
    'Peso': Peso,
    'Talla': Talla,
    'Edad_Gest': Edad_Gest,
    'AlturaREN': AlturaREN
}
input_df = pd.DataFrame([input_dict])

# Inicializar todas las columnas esperadas por el modelo
for col in expected_columns:
    if col not in input_df.columns:
        input_df[col] = 0

# Activar la dummy correspondiente a la provincia si est√° presente
col_prov = f'Provincia_{Provincia}'
if col_prov in input_df.columns:
    input_df[col_prov] = 1

# Asegurar orden de columnas
input_data = input_df[expected_columns]

# === Control de predicci√≥n persistente ===
input_hash = hash(str([Provincia, Edad, Ppg, Peso, Talla, Edad_Gest, AlturaREN]))
if st.session_state.get("last_input_hash") != input_hash:
    st.session_state.pop("prediction", None)
    st.session_state.pop("probabilities", None)
    st.session_state["last_input_hash"] = input_hash

if st.button("Predecir diagn√≥stico nutricional"):
    st.session_state["prediction"] = model.predict(input_data)[0]
    st.session_state["probabilities"] = model.predict_proba(input_data)[0]

if "prediction" in st.session_state and "probabilities" in st.session_state:
    pred = st.session_state["prediction"]
    probs = st.session_state["probabilities"]

    st.subheader(f"üìå Diagn√≥stico predicho: **{pred}**")
    try:
        with open(f"{pred}.jpg", "rb") as image_file:
            img_bytes = image_file.read()
            img_base64 = base64.b64encode(img_bytes).decode()
            st.markdown(
                f"""
                <div style="text-align:center;">
                    <img src="data:image/jpg;base64,{img_base64}" width="250">
                    <p><b>Resultado: {pred}</b></p>
                </div>
                """,
                unsafe_allow_html=True
            )
    except:
        st.info("Puedes agregar im√°genes como 'D√©ficit.jpg', 'Normal.jpg' o 'Sobrepeso.jpg'.")



# === VISUALIZACIONES ===
# 1. Muestra del dataset
if show_sample:
    st.subheader("üìã Mostrar muestra del dataset")
    num_rows = st.sidebar.slider("N√∫mero de filas a mostrar", 1, 20, 5)
    st.dataframe(df.head(num_rows))

# === ALINEAR X_test con el modelo ===
for col in model.feature_names_in_:
    if col not in X_test.columns:
        X_test[col] = 0  # columna faltante con 0
X_test_aligned = X_test[model.feature_names_in_]

# === PREDICCI√ìN GLOBAL ===
y_pred = model.predict(X_test_aligned)
y_prob = model.predict_proba(X_test_aligned)

# 2. M√©tricas del modelo
if show_metrics:
    st.subheader("üìä M√©tricas del modelo")

    # Asegurar que X_test tenga las mismas columnas que espera el modelo
    for col in model.feature_names_in_:
        if col not in X_test.columns:
            X_test[col] = 0  # columnas faltantes con 0

    X_test_aligned = X_test[model.feature_names_in_]  # asegurar el mismo orden

    y_pred = model.predict(X_test_aligned)
    acc = accuracy_score(y_test, y_pred)
    prec = precision_score(y_test, y_pred, average='macro')
    rec = recall_score(y_test, y_pred, average='macro')
    f1 = f1_score(y_test, y_pred, average='macro')

    metrics_df = pd.DataFrame([
        ['Accuracy', acc],
        ['Precision', prec],
        ['Recall', rec],
        ['F1 Score', f1]
    ], columns=['M√©trica', 'Valor'])

    st.write(metrics_df.style.background_gradient(cmap='PuBu').bar(subset=['Valor'], color='#0A3871'))


if show_conf_matrix:
    st.subheader("üìâ Matriz de Confusi√≥n")
    fig, ax = plt.subplots(figsize=(5, 3))
    ConfusionMatrixDisplay.from_predictions(
        y_test, y_pred, ax=ax, cmap='PuBu', display_labels=model.classes_
    )
    ax.set_title("Matriz de Confusi√≥n")
    st.pyplot(fig)

# 4. Curva ROC
if show_roc:
    st.subheader("üìà Curva ROC por clase")

    lb = LabelBinarizer()
    y_test_bin = lb.fit_transform(y_test)

    fig_roc, ax = plt.subplots(figsize=(6, 4))
    for i, class_label in enumerate(model.classes_):
        fpr, tpr, _ = roc_curve(y_test_bin[:, i], y_prob[:, i])
        auc = roc_auc_score(y_test_bin[:, i], y_prob[:, i])
        ax.plot(fpr, tpr, label=f"{class_label} (AUC = {auc:.2f})")

    ax.plot([0, 1], [0, 1], "k--")
    ax.set_xlabel("Falsos positivos")
    ax.set_ylabel("Verdaderos positivos")
    ax.set_title("Curva ROC por clase")
    ax.legend()
    st.pyplot(fig_roc)